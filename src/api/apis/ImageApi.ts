/* tslint:disable */
/* eslint-disable */
/**
 * recraft.ai external api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GenerateImageRequest,
  GenerateImageResponse,
  ImageFormat,
  ImageStyle,
  ImageSubStyle,
  ProcessImageResponse,
  ResponseFormat,
  TextLayoutItem,
  TransformModel,
  UserControls,
} from '../models/index';
import {
    GenerateImageRequestFromJSON,
    GenerateImageRequestToJSON,
    GenerateImageResponseFromJSON,
    GenerateImageResponseToJSON,
    ImageFormatFromJSON,
    ImageFormatToJSON,
    ImageStyleFromJSON,
    ImageStyleToJSON,
    ImageSubStyleFromJSON,
    ImageSubStyleToJSON,
    ProcessImageResponseFromJSON,
    ProcessImageResponseToJSON,
    ResponseFormatFromJSON,
    ResponseFormatToJSON,
    TextLayoutItemFromJSON,
    TextLayoutItemToJSON,
    TransformModelFromJSON,
    TransformModelToJSON,
    UserControlsFromJSON,
    UserControlsToJSON,
} from '../models/index';

export interface ClarityUpscaleRequest {
    image: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

export interface CreativeUpscaleRequest {
    image: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

export interface CrispUpscaleRequest {
    image: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

export interface EraseRegionRequest {
    image: Blob;
    mask: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

export interface GenerateBackgroundRequest {
    image: Blob;
    mask: Blob;
    prompt: string;
    n?: number;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
    styleId?: string;
    style?: ImageStyle;
    substyle?: ImageSubStyle;
    model?: TransformModel;
    randomSeed?: number;
    textLayout?: Array<TextLayoutItem>;
    blockNsfw?: boolean;
    calculateFeatures?: boolean;
    negativePrompt?: string;
}

export interface GenerateImageOperationRequest {
    generateImageRequest?: GenerateImageRequest;
}

export interface GenerativeUpscaleRequest {
    image: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

export interface ImageToImageRequest {
    image: Blob;
    prompt: string;
    strength: number;
    n?: number;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
    styleId?: string;
    style?: ImageStyle;
    substyle?: ImageSubStyle;
    controls?: UserControls;
    model?: TransformModel;
    randomSeed?: number;
    textLayout?: Array<TextLayoutItem>;
    blockNsfw?: boolean;
    calculateFeatures?: boolean;
    negativePrompt?: string;
}

export interface InpaintImageRequest {
    image: Blob;
    mask: Blob;
    prompt: string;
    n?: number;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
    styleId?: string;
    style?: ImageStyle;
    substyle?: ImageSubStyle;
    model?: TransformModel;
    randomSeed?: number;
    textLayout?: Array<TextLayoutItem>;
    blockNsfw?: boolean;
    calculateFeatures?: boolean;
    negativePrompt?: string;
}

export interface RemoveBackgroundRequest {
    image: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

export interface ReplaceBackgroundRequest {
    image: Blob;
    mask: Blob;
    prompt: string;
    n?: number;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
    styleId?: string;
    style?: ImageStyle;
    substyle?: ImageSubStyle;
    model?: TransformModel;
    randomSeed?: number;
    textLayout?: Array<TextLayoutItem>;
    blockNsfw?: boolean;
    calculateFeatures?: boolean;
    negativePrompt?: string;
}

export interface VectorizeImageRequest {
    image: Blob;
    responseFormat?: ResponseFormat;
    imageFormat?: ImageFormat;
}

/**
 * 
 */
export class ImageApi extends runtime.BaseAPI {

    /**
     * Clarity Upscale
     * @deprecated
     */
    async clarityUpscaleRaw(requestParameters: ClarityUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling clarityUpscale().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/clarityUpscale`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Clarity Upscale
     * @deprecated
     */
    async clarityUpscale(requestParameters: ClarityUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.clarityUpscaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creative Upscale
     */
    async creativeUpscaleRaw(requestParameters: CreativeUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling creativeUpscale().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/creativeUpscale`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Creative Upscale
     */
    async creativeUpscale(requestParameters: CreativeUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.creativeUpscaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Crisp Upscale
     */
    async crispUpscaleRaw(requestParameters: CrispUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling crispUpscale().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/crispUpscale`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Crisp Upscale
     */
    async crispUpscale(requestParameters: CrispUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.crispUpscaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Erase Region
     */
    async eraseRegionRaw(requestParameters: EraseRegionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling eraseRegion().'
            );
        }

        if (requestParameters['mask'] == null) {
            throw new runtime.RequiredError(
                'mask',
                'Required parameter "mask" was null or undefined when calling eraseRegion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['mask'] != null) {
            formParams.append('mask', requestParameters['mask'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/eraseRegion`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Erase Region
     */
    async eraseRegion(requestParameters: EraseRegionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.eraseRegionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate Background
     */
    async generateBackgroundRaw(requestParameters: GenerateBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling generateBackground().'
            );
        }

        if (requestParameters['mask'] == null) {
            throw new runtime.RequiredError(
                'mask',
                'Required parameter "mask" was null or undefined when calling generateBackground().'
            );
        }

        if (requestParameters['prompt'] == null) {
            throw new runtime.RequiredError(
                'prompt',
                'Required parameter "prompt" was null or undefined when calling generateBackground().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['mask'] != null) {
            formParams.append('mask', requestParameters['mask'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        if (requestParameters['styleId'] != null) {
            formParams.append('style_id', requestParameters['styleId'] as any);
        }

        if (requestParameters['style'] != null) {
            formParams.append('style', requestParameters['style'] as any);
        }

        if (requestParameters['substyle'] != null) {
            formParams.append('substyle', requestParameters['substyle'] as any);
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['randomSeed'] != null) {
            formParams.append('random_seed', requestParameters['randomSeed'] as any);
        }

        if (requestParameters['textLayout'] != null) {
            formParams.append('text_layout', requestParameters['textLayout']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['blockNsfw'] != null) {
            formParams.append('block_nsfw', requestParameters['blockNsfw'] as any);
        }

        if (requestParameters['calculateFeatures'] != null) {
            formParams.append('calculate_features', requestParameters['calculateFeatures'] as any);
        }

        if (requestParameters['negativePrompt'] != null) {
            formParams.append('negative_prompt', requestParameters['negativePrompt'] as any);
        }

        const response = await this.request({
            path: `/v1/images/generateBackground`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateImageResponseFromJSON(jsonValue));
    }

    /**
     * Generate Background
     */
    async generateBackground(requestParameters: GenerateBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateImageResponse> {
        const response = await this.generateBackgroundRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate image from prompt
     */
    async generateImageRaw(requestParameters: GenerateImageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateImageResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/images/generations`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateImageRequestToJSON(requestParameters['generateImageRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateImageResponseFromJSON(jsonValue));
    }

    /**
     * Generate image from prompt
     */
    async generateImage(requestParameters: GenerateImageOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateImageResponse> {
        const response = await this.generateImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generative Upscale
     * @deprecated
     */
    async generativeUpscaleRaw(requestParameters: GenerativeUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling generativeUpscale().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/generativeUpscale`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Generative Upscale
     * @deprecated
     */
    async generativeUpscale(requestParameters: GenerativeUpscaleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.generativeUpscaleRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate image from image and prompt
     */
    async imageToImageRaw(requestParameters: ImageToImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling imageToImage().'
            );
        }

        if (requestParameters['prompt'] == null) {
            throw new runtime.RequiredError(
                'prompt',
                'Required parameter "prompt" was null or undefined when calling imageToImage().'
            );
        }

        if (requestParameters['strength'] == null) {
            throw new runtime.RequiredError(
                'strength',
                'Required parameter "strength" was null or undefined when calling imageToImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['strength'] != null) {
            formParams.append('strength', requestParameters['strength'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        if (requestParameters['styleId'] != null) {
            formParams.append('style_id', requestParameters['styleId'] as any);
        }

        if (requestParameters['style'] != null) {
            formParams.append('style', requestParameters['style'] as any);
        }

        if (requestParameters['substyle'] != null) {
            formParams.append('substyle', requestParameters['substyle'] as any);
        }

        if (requestParameters['controls'] != null) {
            formParams.append('controls', new Blob([JSON.stringify(GenerateImageResponseToJSON(requestParameters['controls']))], { type: "application/json", }));
                    }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['randomSeed'] != null) {
            formParams.append('random_seed', requestParameters['randomSeed'] as any);
        }

        if (requestParameters['textLayout'] != null) {
            formParams.append('text_layout', requestParameters['textLayout']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['blockNsfw'] != null) {
            formParams.append('block_nsfw', requestParameters['blockNsfw'] as any);
        }

        if (requestParameters['calculateFeatures'] != null) {
            formParams.append('calculate_features', requestParameters['calculateFeatures'] as any);
        }

        if (requestParameters['negativePrompt'] != null) {
            formParams.append('negative_prompt', requestParameters['negativePrompt'] as any);
        }

        const response = await this.request({
            path: `/v1/images/imageToImage`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateImageResponseFromJSON(jsonValue));
    }

    /**
     * Generate image from image and prompt
     */
    async imageToImage(requestParameters: ImageToImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateImageResponse> {
        const response = await this.imageToImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inpaint Image
     */
    async inpaintImageRaw(requestParameters: InpaintImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling inpaintImage().'
            );
        }

        if (requestParameters['mask'] == null) {
            throw new runtime.RequiredError(
                'mask',
                'Required parameter "mask" was null or undefined when calling inpaintImage().'
            );
        }

        if (requestParameters['prompt'] == null) {
            throw new runtime.RequiredError(
                'prompt',
                'Required parameter "prompt" was null or undefined when calling inpaintImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['mask'] != null) {
            formParams.append('mask', requestParameters['mask'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        if (requestParameters['styleId'] != null) {
            formParams.append('style_id', requestParameters['styleId'] as any);
        }

        if (requestParameters['style'] != null) {
            formParams.append('style', requestParameters['style'] as any);
        }

        if (requestParameters['substyle'] != null) {
            formParams.append('substyle', requestParameters['substyle'] as any);
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['randomSeed'] != null) {
            formParams.append('random_seed', requestParameters['randomSeed'] as any);
        }

        if (requestParameters['textLayout'] != null) {
            formParams.append('text_layout', requestParameters['textLayout']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['blockNsfw'] != null) {
            formParams.append('block_nsfw', requestParameters['blockNsfw'] as any);
        }

        if (requestParameters['calculateFeatures'] != null) {
            formParams.append('calculate_features', requestParameters['calculateFeatures'] as any);
        }

        if (requestParameters['negativePrompt'] != null) {
            formParams.append('negative_prompt', requestParameters['negativePrompt'] as any);
        }

        const response = await this.request({
            path: `/v1/images/inpaint`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateImageResponseFromJSON(jsonValue));
    }

    /**
     * Inpaint Image
     */
    async inpaintImage(requestParameters: InpaintImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateImageResponse> {
        const response = await this.inpaintImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove background
     */
    async removeBackgroundRaw(requestParameters: RemoveBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling removeBackground().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/removeBackground`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Remove background
     */
    async removeBackground(requestParameters: RemoveBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.removeBackgroundRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace Background
     */
    async replaceBackgroundRaw(requestParameters: ReplaceBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling replaceBackground().'
            );
        }

        if (requestParameters['mask'] == null) {
            throw new runtime.RequiredError(
                'mask',
                'Required parameter "mask" was null or undefined when calling replaceBackground().'
            );
        }

        if (requestParameters['prompt'] == null) {
            throw new runtime.RequiredError(
                'prompt',
                'Required parameter "prompt" was null or undefined when calling replaceBackground().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['mask'] != null) {
            formParams.append('mask', requestParameters['mask'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        if (requestParameters['styleId'] != null) {
            formParams.append('style_id', requestParameters['styleId'] as any);
        }

        if (requestParameters['style'] != null) {
            formParams.append('style', requestParameters['style'] as any);
        }

        if (requestParameters['substyle'] != null) {
            formParams.append('substyle', requestParameters['substyle'] as any);
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['randomSeed'] != null) {
            formParams.append('random_seed', requestParameters['randomSeed'] as any);
        }

        if (requestParameters['textLayout'] != null) {
            formParams.append('text_layout', requestParameters['textLayout']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['blockNsfw'] != null) {
            formParams.append('block_nsfw', requestParameters['blockNsfw'] as any);
        }

        if (requestParameters['calculateFeatures'] != null) {
            formParams.append('calculate_features', requestParameters['calculateFeatures'] as any);
        }

        if (requestParameters['negativePrompt'] != null) {
            formParams.append('negative_prompt', requestParameters['negativePrompt'] as any);
        }

        const response = await this.request({
            path: `/v1/images/replaceBackground`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateImageResponseFromJSON(jsonValue));
    }

    /**
     * Replace Background
     */
    async replaceBackground(requestParameters: ReplaceBackgroundRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateImageResponse> {
        const response = await this.replaceBackgroundRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Vectorize image
     */
    async vectorizeImageRaw(requestParameters: VectorizeImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ProcessImageResponse>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling vectorizeImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("auth0", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['responseFormat'] != null) {
            formParams.append('response_format', requestParameters['responseFormat'] as any);
        }

        if (requestParameters['imageFormat'] != null) {
            formParams.append('image_format', requestParameters['imageFormat'] as any);
        }

        const response = await this.request({
            path: `/v1/images/vectorize`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProcessImageResponseFromJSON(jsonValue));
    }

    /**
     * Vectorize image
     */
    async vectorizeImage(requestParameters: VectorizeImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ProcessImageResponse> {
        const response = await this.vectorizeImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
